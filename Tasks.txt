Задание №1 (для всех направлений)


Решения присылайте на мыло p.lebedev@itransition.com в виде ссылки на Dropbox на файл lcs.js (нужна именно public-ссылка, аттачи или ссылки куда-то еще приниматься не будут, так как решения проверяются скриптом).

Требуется разработать на языке JavaScript код, печатающий на консоль самую длинную общую подстроку всех переданных строк. Строки передаются параметрами командной строки в ваш JavaScript, выполняемый под Node.js. Если самая длинная общая подстрока является пустой строкой (например, не было передано ни одной строки или строки не имеют общих для всех символов), напечатать од

ин перевод строки (пустую строку). При существовании нескольких решений — напечатать одно решение (любое). Вывод всегда сопровождается переводом строки. Ограничения: длина одной строки не превосходит 256 символов, количество строк не превосходит 64, строки содержат только латинские буквы и арабские цифры, время выполнения одного теста - не более пяти секунд, вывод не содержит посторонних символов. Ограничения не должны быть в вашем коде, это ограничения на автоматические тесты.
Решение будет приниматься при прохождении набора тестов, результат будет оцениваться исходя из размера файла в байтах (меньше — лучше). Соответственно, никаких комментариев, длинных имён, отступов и прочего.
Файл должен иметь имя lcs.js (вот именно такое). Обязательно использование параметров командной строки (никаких readline, process.stdin и т.п.; ТОЛЬКО process.argv).
При вызове без параметров (node lcs.js) скрипт должен выводить один перевод строки ("пустую строку").
Нужна именно public-ссылка на Dropbox (c длинных hex-идентификатором). Не пытайтесь шарить файл с p.lebedev@itransition.com (проверяющий скрипт работает, конечно, от другого мыла).
Если одно из этих условий не будет выполнено, по заданию автомагически будет оценка 0.

Пример:
node lcs.js ABCDEFZ WBCDXYZ
BCD
Несколько возможных тестов (в случае существования нескольких решений вывод может отличаться в соответствии с условием задачи):
node lcs.js 132 12332 12312
1
node lcs.js ABCDEFGH ABCDEFG ABCEDF ABCED
ABC
node lcs.js ABCDEFGH ABCDEFG ABCEDF ABCED
ABC
node lcs.js ABCDEFGH ABCDEFG ABCDEF ABCDE
ABCDE
node lcs.js ABCDEFGH ABCDEFG ABCDEF ABCDE EDCBA
A
node lcs.js ABCDEFGH ABCDEFG ABCDEF ABCDE EDCBCA
BC
node lcs.js ABCDEFGH ABCDEFG AxBCDEF ABCDxE EDCBCAABCD
BCD
node lcs.js ABCDEFGH 1234
node lcs.js ABCDEFGH
ABCDEFGH

Задание №2. 

Для тех, кто уже прислал №1. Для всех направлений (для DevOps обязательно Python).

На языке с динамической типизацией (можно выбрать Python 3 или Ruby или JavaScript; +50% за два языка, +100% за три; для DevOps-хакеров обязательно Python 3) реализовать скрипт, который выводит по одной строке для каждого файла в текущей папке: имя файла, пробел, содержащей значение SHA3-256 от содержимого файла (в хексе). Больше ничего не выводится. Если папка пустая, то не выводится ничего. Если папка содержит 10 файлов — выводятся 10 строк и т.д.
На адрес p.lebedev@itransition.com нужно прислать скришот кода и скриншот с выводом на папке, содержащей файл нулевой длины и файл, содержащий 'abc' (три байта 97, 98, 99).
Вот тут можно посмотреть тестовые векторы — https://www.di-mgt.com.au/sha_testvectors.html (для пустого файла должно быть a7ffc6f8bf1ed766 51c14756a061d662 f580ff4de43b49fa 82d80a4b80f8434a, для abc должно быть 3a985da74fe225b2 045c172d6bd390bd 855f086e3e9d525b 46bfe24511431532).
В вашем коде не должно быть лишних условий, например, алгоритм SHA-3 обрабатывает пустые строки сам. Так же не должно быть выбора по типам файлов и т.п.
Обратите внимание, что речь идёт о текущей папке (https://en.wikipedia.org/wiki/Working_directory), текущая папка — это не папка, в которой лежит скрипт, скрипт может запускаться с указанием пути к нему, как относительного, включая вверх по папкам, так и абсолютного. НУЖНО ИСПОЛЬЗОВАТЬ ТЕКУЩУЮ ПАПКУ. Обычно для этого нужно меньше кода, а не больше. В целом, стоит ориентироваться на 2-5 строк кода, это тривиальная задача. Если у вас портянка на половину экрана — вы пилите что-то лишнее.
И еще раз: ОБРАТИТЕ ВНИМАНИЕ, ЧТО В №2 речь идёт o process working dir, а не папке, которая передаётся параметром.

Задание №3. Для тех, кто уже сдал №1 и №2.

ДЛЯ ВСЕХ НАПРАВЛЕНИЙ

На языке со статической типизацией (на выбор Java или C#) реализовать скрипт (в виде jar-файла или исполняемой сборки), который реализует *обобщенную* игру камень-ножницы-бумага.
При запуске параметрами командной строки (аргументы метода main или Main) передаётся нечётное число >=3 неповторяющихся строк (при неправильно заданных аргументах вывести аккуратное сообщение об ошибке — что неверно, пример как правильно). Эти строки — это ходы (например, Камень Ножницы Бумага или Камень Ножницы Бумага Ящерица Спок). Победа определяется так — половина следующих выигрывает, половина предыдущих проигрывает (по кругу).
Скрипт генерирует случайный ключ (SecureRandom или RandomNumberGenerator — обязательно!) длиной 128 бит, делает свой ход, вычисляет HMAC (на базе SHA2 или SHA3) от хода со сгенерированным ключом, показывает пользователя HMAC. После этого пользователь получает "меню" 1 - Камень, 2 - Ножницы, ...., 0 - Exit. Пользователь делает свой выбор (при некорректном вводе опять отображается "меню"). Скрипт показывает кто победил, ход компьютера и исходный ключ.
Таким образом, пользователь может проверить, что компьютер играет честно (не поменял свой ход после хода пользователя).
Пример:
>java -jar gamr.jar rock paper scissors lizard Spock
HMAC: FAAC40C71B4B12BF0EF5556EEB7C06925D5AE405D447E006BB8A06565338D411
Available moves:
1 - rock
2 - paper
3 - scissors
4 - lizard
5 - Spock
0 - exit
Enter your move: 2
Your move: paper
Computer move: rock
You win!
HMAC key: BD9B5544739FCE7359C267E734E380A2
Для сдачи нужно прислать на p.lebedev@itransition.com:
1) ссылку на видео, демонстрирующее запуск с 3 и 7 параметрами, запуск с неправильными параметрами (повторение или чётное число, один или отсутствие), выбор хода, вывод результатов;
2) исходный код ссылкой на гитхаб.
И как пояснение: при вычислении HMAC ключ — это тот самый секретный ключ, который вы сгенерировали. А сообщение — это ход (прямо вот строка хода). После хода пользователя у него будет ключ, ход компьютера, пользователь сможет вычислить HMAC и сравнить с HMAC-ом, который был показан до хода пользователя. Это не очень сложно :))
Частая ошибка — попытка изобрести свой "HMAC" как хэш от случайного "ключа". Это бессмысленно. Если вы показываете одинаковые строки до хода и после хода, пользователь после хода не получает новой информации и, соответсвенно, вы ничего ему не доказываете. Нужно сгенерировать ключ (безопасным генератором), сделать ход компа, вычислить HMAC (стандартным алгоритмом) от хода компа (сообщение) и ключа (ключ), показать HMAC, получить ход пользователя, показать ключ. Перечитывать этот абзац до полного вкуривания.

Задание 4
Для всех направлений. Язык по выбору из следующего списка: Java/C#/Ruby/Python3/PHP/JavaScript.
Требуется реализовать скрипт, запускаемый из командной строки — параметры читаются исключительно из аргументов командной строки, никаких gets-ов и прочих readline-ов!
Скрипт должен генерировать "фейковые" пользовательские данные (тестовые данные для наполнения баз пользователей).
Каждая запись (один пользователь) выводится на отдельной строке, поля разделены точкой с запятой. 
Запись должна содержать ФИО, полный адрес, телефон. Адрес должен приблизительно соответствовать региону, более-менее реалистичные индексы и зип-коды, например. Необходимо, чтобы формат адреса не был в каждой записи одинаковым, где-то страна написана полностью, где-то  нет (United States/US). 
Первый параметр (целое число) — число записей >0.
Второй параметр (строка) — регион, en_US, ru_RU и на выбор uk_UA или be_BY. Фамилии и адреса должны быть на заданном языке (на английском/русском/украинском/беларуском соотв.).
Для вывода необходимо использовать готовые CSV-форматтер (например, если поле содержит разделитель, последний должен быть правильно заэскейплен).
Ориентироваться нужно примерно на масштаб 10_000_000 записей. Ориентируйтесь, что миллион должен генерироваться до минуты (без учета вывода в терминал).
Как сдавать: на адрес p.lebedev@itransition.com прислать ссылку на код и видео с записью запуска с разными регионами на 10 записях и запуска в любом регионе на 1000000 с перенаправлением вывода в /dev/null (для нескучной ОС — NUL).
Как обычно, велосипед не изобретаем, используем биб-ки для генерации тестовых данных.

Задание 5

На указанной платформе (.NET - Core/ASP.NET MVC в любом реинкарнации, EntityFramework,SQL Server | Java - Spring/Hibernate/MySQL | Front - JavaScript/React/Node.js/Express/MySQL | Web - PHP/Symfony(опционально) | Python+DevOps - Python/Django) реализовать простейшее Web-приложение, которое позволяет пользователям зарегистрироваться и аутентифицироваться.
Неаутентифицированные пользователи не имеют доступа к управлению пользователями (могут достучаться только к форме регистрации или форме аутентификации).
Аутентифицированные пользователи видят таблицу (таблица с идентификатором, именем, мылом, датой регистрации, датой последнего логина, статусом) с пользователями. Таблица левой колонкой содержит чек-боксы для множественного выделения, в заголовке колонки чек-бокс "выделить все/снять выделение". Над таблицей *тулбар* с действиями: Block (текст), Unblock (иконка), Delete (иконка). Пользователь может удалить или заблокировать себя — при этом сразу должен быть разлогинен. Если кто-то другой блокирует или удаляет пользователя, то при любом следующем действии пользователь переправляется на страницу логина.
Таблица, множественное выделение, тулбар — обязательно.
ТРЕБОВАНИЕ: Обязательно использование CSS-фреймворка (рекомендация — Bootstrap, но он не обязателен, можно любой другой CSS-фреймворк).
Сайт (формы логина/регистрации, таблица с пользователямя) должен корректно отображаться на разных разрешениях (это должен автомагически дать CSS-фреймворк).
При регистрации должна быть возможность использовать любой пароль, даже из одного символа (разберитесь, как настроить соотв. политики, чтобы было просто разрабатывать и тестировать).
При отправки задания на p.lebedev@itransition.com указать ФИО (можно без О) и следующие ссылки:
1) Cсылка на Github.
2) Ссылка на задеплоенный проект (без разницы где — Azure, Heroku, что угодно).
3) Записанное видео, в котором отображается с задеплоенного сайта регистрация, вход, выделение одного пользователя (не себя), его блокировка и демонстрация результата (статус в таблице обновился), разблокировка этого пользователя, выделение всех пользователей через клик на чекбокс в заголовке таблице, блокировка всех (включая себя) нажатием кнопки на тулбаре "Block" (так как себя, то с автомагическим переходом на страницу входа)